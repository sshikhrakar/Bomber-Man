<!DOCTYPE html>
<html>
	<head>
		<style>
		*{
			margin:0;
			padding:0;
			font-family:calibri;
		}
		.bomberman {
			position: absolute;
			height: 50px;
			width: 50px;
			background:url('hero.png');
		}
		
		.gunda {
			position: absolute;
			height:50px;
			width: 50px;
		}
		
		.block {
			position: absolute;
			height: 50px;
			width: 50px;
		}

		.block1 {
			background:url('green.png') ;
		}
		.block2 {
			background: url('box.png');
		}

		.block3 {
			background: url('wall.png');
			position:absolute;
		}
		.block4 {
			background: url('left-wall.png');
			position:absolute;
		}
		.bomb{
			position: absolute;
			height: 50px;
			width: 50px;
			background: url('bomb.png');
		}
		#scoreBar{
			width:550px;
			line-height:50px;
			color:white;
			background:url('score-board.png');
			float:left;
		}
		#main-screen{
			width:550px;
			height:550px;
			background: url('bg.png') repeat;
			position:relative;
			float:left;
		}
		#wrapper{
			width:550px;
			margin:0 auto;
		display:table;
		}
	</style>
	</head>
	<body>
		<div id="wrapper">
			<div id ="scoreBar"></div>
			<div id ="main-screen">
			</div>
		</div>
	</body>
	<script>
		;(function(){
			'use strict';
			var counterBomb = 1;
			function Block() {
				
				var that = this;

				this.htmlElement = document.createElement('div');

				this.x = 0;
				this.y = 0;

				this.type;

				this.init = function(type, tileSheetX, tileSheetY) {
					that.htmlElement.className = 'block block'+type;
					that.x = tileSheetX * 50;
					that.y = tileSheetY * 50;
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';

					that.type = type;
				};
			};

			function BomberMan() {

				var that = this;
				
				this.htmlElement = document.createElement('div');

				this.x = 50;
				this.y = 50;
				this.velocityX = 0;
				this.velocityY = 0;
				this.bombLimit=3;

				this.init = function() {
					that.htmlElement.className = 'bomberman';
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
					initKeyEvents();
				};

				this.updatePosition = function() {
					if(that.x < 50) {
						that.velocityX = 0;
						that.x = 50;
					}
					if(that.x > 450) {
						that.velocityX = 0;
						that.x = 450;
					}
					if(that.y < 50){
						that.velocityY = 0;
						that.y = 50;
					}
					if(that.y > 450){
						that.velocityY = 0;
						that.y = 450;
					}
					that.x += that.velocityX;
					that.y += that.velocityY;
					// console.log(that.x);
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
				};

				//Private methods

				var initKeyEvents = function() {
					var x = that.htmlElement.style.left;
					var y = that.htmlElement.style.top;
					window.onkeydown = function(event){
						// console.log(event.which);
						if(event.which===39){
							that.velocityX = 50;
						}
						if(event.which===37){
							that.velocityX = -50;
						}
						if(event.which===40){
							that.velocityY = 50;
						}
						if(event.which===38){
							that.velocityY = -50;
						}
						if(event.which===87){
							if(that.bombLimit>0 && counterBomb===1){
							var bomb = new Bomb();
							bomb.init(that.x,that.y);
							that.bombLimit-=1;
							if(that.bombLimit<0){
								that.bombLimit=0;
							}
							counterBomb=0;
							}
							
						}
					};
					window.onkeyup = function(event){
						that.velocityX = 0;
						that.velocityY = 0;
					};
				};
			};
			
			function Enemy(x,y){
				var that = this;

				this.htmlElement = document.createElement('div');

				this.x = x;
				this.y = y;
				this.velocityX = 0;
				this.velocityY = 0;

				this.init = function() {
					that.htmlElement.className = 'gunda';
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
					that.htmlElement.style.background = 'url(enemy.png)';
				}
				this.type2=function(){
					that.htmlElement.className = 'gunda';
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
					that.htmlElement.style.background = 'url(fly_fly.png) no-repeat';
				}
				this.path=[];
				this.pathCounter=0;
				this.canMoveReverse = false;
				this.updatePosition = function(path) {

					var cord = [];
					var nextTargetX = 0;
					var nextTargetY = 0;

					// if (that.pathCounter < path.length) {
					if (that.canMoveReverse === false) {
						
						cord = path[that.pathCounter];
						nextTargetX = cord[0]*50;
						nextTargetY = cord[1]*50;
						// delaythis(that.pathCounter);
						
						if (that.pathCounter > 0) {
							var prevCord = path[that.pathCounter - 1];
							var prevCordX=prevCord[0]*50;
							var prevCordY=prevCord[1]*50;
							//check if x has changed
							
							if (nextTargetX === prevCordX) {
								//change Y							
								if (nextTargetY>prevCordY){
									that.y+=5;
								}
								else if (nextTargetY<prevCordY){
									that.y-= 5;
								}
								if (that.y === nextTargetY){
									that.pathCounter++;
								}
								
							} else if (nextTargetY === prevCordY) {
								//change X
								if (nextTargetX>prevCordX){
									that.x+=5;
								}
								else if (nextTargetX<prevCordX){
									that.x-= 5;
								}
								
								if (that.x === nextTargetX){
									that.pathCounter++;
								}
							}
						} else {
							that.pathCounter++;	
						}
						
						if (that.pathCounter >= path.length) {
							that.canMoveReverse = true;
							that.pathCounter = path.length-1;
						}
						
					}else{
						
						cord = path[that.pathCounter];
						nextTargetX = cord[0]*50;
						nextTargetY = cord[1]*50;
						// delaythis(that.pathCounter);
						
						if (that.pathCounter < path.length-1) {
							var prevCord = path[that.pathCounter + 1];
							var prevCordX=prevCord[0]*50;
							var prevCordY=prevCord[1]*50;
							//check if x has changed
							
							if (nextTargetX === prevCordX) {
								//change Y							
								if (nextTargetY>prevCordY){
									that.y+=5;
								}
								else if (nextTargetY<prevCordY){
									that.y-= 5;
								}
								if (that.y === nextTargetY){
									that.pathCounter--;
								}
								
							} else if (nextTargetY === prevCordY) {
								//change X
								if (nextTargetX>prevCordX){
									that.x+=5;
								}
								else if (nextTargetX<prevCordX){
									that.x-= 5;
								}
								
								if (that.x === nextTargetX){
									that.pathCounter--;
								}
							}
						} else {
							that.pathCounter--;	
						}
						
						if (that.pathCounter < 0) {
							that.canMoveReverse = false;
							that.pathCounter = 0;
						}
						
					}
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
					//that.pathCounter++;
				};

			};
			
			function Bomb(){
				var that = this;

				this.htmlElement = document.createElement('div');

				this.x = 0;
				this.y = 0;

				this.init = function(x,y) {
					that.x=x;
					that.y=y;
					that.htmlElement.className = 'bomb';
					that.htmlElement.style.left = that.x + 'px';
					that.htmlElement.style.top = that.y + 'px';
					var gameW = new GameWorld();
					console.log(that.bombLimit);
					gameW.htmlElement.appendChild(that.htmlElement);
					setTimeout(explode,4000);
				};
				
				var explode = function(){
					that.htmlElement.remove();
					counterBomb=1;
				}
			};

			function GameWorld() {

				var that = this;
				this.htmlElement = document.getElementById('main-screen');
				this.scoreBoard = document.getElementById('scoreBar');
				this.mainGameLooper;

				this.bomberMan;
				this.enemy;
				this.blocks = [];
				var level1TileMapInfo = [
					[4,4,4,4,4,4,4,4,4,4,3],
					[3,0,0,0,0,2,0,0,0,0,3],
					[3,0,1,0,1,0,1,0,1,0,3],
					[3,0,0,0,0,0,0,0,0,0,3],
					[3,0,1,0,1,0,1,2,1,0,3],
					[3,0,0,2,0,0,0,0,0,0,3],
					[3,0,1,0,1,0,1,0,1,0,3],
					[3,0,0,0,0,0,0,0,0,2,3],
					[3,0,1,0,1,0,1,0,1,0,3],
					[3,0,0,0,0,0,2,0,0,0,3],
					[4,4,4,4,4,4,4,4,4,4,3]
				];

				this.init = function() {
					generateTileMap(level1TileMapInfo);
					that.bomberMan = new BomberMan();
					that.bomberMan.init();
					that.enemy = new Enemy(50,450);
					that.enemy2 = new Enemy(450,450);
					that.enemy3 = new Enemy(450,50);
					that.enemy4 = new Enemy(450,250);
					that.enemy.type2();
					that.enemy2.init();
					that.enemy3.init();
					that.enemy4.type2();

					that.htmlElement.appendChild(that.bomberMan.htmlElement);
					that.htmlElement.appendChild(that.enemy.htmlElement);
					that.htmlElement.appendChild(that.enemy2.htmlElement);
					that.htmlElement.appendChild(that.enemy3.htmlElement);
					that.htmlElement.appendChild(that.enemy4.htmlElement);
					this.mainGameLooper = setInterval(mainGameLoop, 100);
				};
				
				var score = function(){
					var bombCount = that.bomberMan.bombLimit;
					that.scoreBoard.innerHTML='Bomb Count= ' +bombCount;
				};
				
				// Private Methods
				
				var mainGameLoop = function() {
					var bomberInitX = that.bomberMan.x;
					var bomberInitY = that.bomberMan.y;
					var prevBomberCordX = bomberInitX;
					var prevBomberCordY = bomberInitY;
					that.bomberMan.updatePosition();
					score();
 					var enemyInitX = that.enemy.x;
					var enemyInitY = that.enemy.y;
					// that.enemy.updatePosition();
					var bomberCordX=bomberInitX/50;
					var bomberCordY=bomberInitY/50;	

					that.enemy.updatePosition(pathValues([1,9],[4,5]));
					that.enemy2.updatePosition(pathValues([9,9],[6,3]));
					that.enemy3.updatePosition(pathValues([9,1],[1,4]));
					that.enemy4.updatePosition(pathValues([9,5],[4,9]));
					//console.log(path);
					
					for(var i=0; i< that.blocks.length; i++) {
						//if collided with block place is back to origin position
						if(checkCollision(that.bomberMan, that.blocks[i])) {
							// console.log("here");
							that.bomberMan.x = bomberInitX;
							that.bomberMan.y = bomberInitY;
							that.bomberMan.velocityX = 0;
							that.bomberMan.velocityY = 0;
							that.bomberMan.updatePosition();
						}
						
						// if(checkCollision(that.enemy, that.blocks[i])) {
							// that.enemy.x = enemyInitX;
							// that.enemy.y = enemyInitY;
							// that.enemy.velocityX = 0;
							// that.enemy.velocityY = 0;
							// that.enemy.updatePosition();
						// }
					}
				};
				
				var pathValues = function(start,end){
						var path = findPath(level1TileMapInfo,start,end);
						return path;
				};
				
				var checkCollision = function(object1, object2) {
					if ((object1.x + 49) > object2.x && object1.x<=(object2.x+49)
					&& (object1.y+49) > object2.y && object1.y<= (object2.y+49)) {
						return true;
					}
					else {
						return false;
					}
				};
				

				var generateTileMap = function(tileMap) {
					for(var i = 0; i<tileMap.length; i++) {
						for(var j = 0; j<tileMap[i].length; j++) {
							if(tileMap[i][j] != 0) {
								var block = new Block();
								block.init(tileMap[i][j],i,j);
								that.blocks.push(block);
								that.htmlElement.appendChild(block.htmlElement);
							}
						}
					}
				};

			};
						
			// world is a 2d array of integers (eg world[10][15] = 0)
			// pathStart and pathEnd are arrays like [5,10]
			function findPath(world, pathStart, pathEnd)
			{
				// shortcuts for speed
				var	abs = Math.abs;
				var	max = Math.max;
				var	pow = Math.pow;
				var	sqrt = Math.sqrt;
			
				// the world data are integers:
				// anything higher than this number is considered blocked
				// this is handy is you use numbered sprites, more than one
				// of which is walkable road, grass, mud, etc
				var maxWalkableTileNum = 0;
			
				// keep track of the world dimensions
			    // Note that this A-star implementation expects the world array to be square: 
				// it must have equal height and width. If your game world is rectangular, 
				// just fill the array with dummy values to pad the empty space.
				var worldWidth = world[0].length;
				var worldHeight = world.length;
				var worldSize =	worldWidth * worldHeight;
			
				// which heuristic should we use?
				// default: no diagonals (Manhattan)
				var distanceFunction = ManhattanDistance;
				var findNeighbours = function(){}; // empty
			
				/*
			
				// alternate heuristics, depending on your game:
			
				// diagonals allowed but no sqeezing through cracks:
				var distanceFunction = DiagonalDistance;
				var findNeighbours = DiagonalNeighbours;
			
				// diagonals and squeezing through cracks allowed:
				var distanceFunction = DiagonalDistance;
				var findNeighbours = DiagonalNeighboursFree;
			
				// euclidean but no squeezing through cracks:
				var distanceFunction = EuclideanDistance;
				var findNeighbours = DiagonalNeighbours;
			
				// euclidean and squeezing through cracks allowed:
				var distanceFunction = EuclideanDistance;
				var findNeighbours = DiagonalNeighboursFree;
			
				*/
			
				// distanceFunction functions
				// these return how far away a point is to another
			
				function ManhattanDistance(Point, Goal)
				{	// linear movement - no diagonals - just cardinal directions (NSEW)
					return abs(Point.x - Goal.x) + abs(Point.y - Goal.y);
				}
			
				function DiagonalDistance(Point, Goal)
				{	// diagonal movement - assumes diag dist is 1, same as cardinals
					return max(abs(Point.x - Goal.x), abs(Point.y - Goal.y));
				}
			
				function EuclideanDistance(Point, Goal)
				{	// diagonals are considered a little farther than cardinal directions
					// diagonal movement using Euclide (AC = sqrt(AB^2 + BC^2))
					// where AB = x2 - x1 and BC = y2 - y1 and AC will be [x3, y3]
					return sqrt(pow(Point.x - Goal.x, 2) + pow(Point.y - Goal.y, 2));
				}
			
				// Neighbours functions, used by findNeighbours function
				// to locate adjacent available cells that aren't blocked
			
				// Returns every available North, South, East or West
				// cell that is empty. No diagonals,
				// unless distanceFunction function is not Manhattan
				function Neighbours(x, y)
				{
					var	N = y - 1,
					S = y + 1,
					E = x + 1,
					W = x - 1,
					myN = N > -1 && canWalkHere(x, N),
					myS = S < worldHeight && canWalkHere(x, S),
					myE = E < worldWidth && canWalkHere(E, y),
					myW = W > -1 && canWalkHere(W, y),
					result = [];
					if(myN)
					result.push({x:x, y:N});
					if(myE)
					result.push({x:E, y:y});
					if(myS)
					result.push({x:x, y:S});
					if(myW)
					result.push({x:W, y:y});
					findNeighbours(myN, myS, myE, myW, N, S, E, W, result);
					return result;
				}
			
				// returns every available North East, South East,
				// South West or North West cell - no squeezing through
				// "cracks" between two diagonals
				function DiagonalNeighbours(myN, myS, myE, myW, N, S, E, W, result)
				{
					if(myN)
					{
						if(myE && canWalkHere(E, N))
						result.push({x:E, y:N});
						if(myW && canWalkHere(W, N))
						result.push({x:W, y:N});
					}
					if(myS)
					{
						if(myE && canWalkHere(E, S))
						result.push({x:E, y:S});
						if(myW && canWalkHere(W, S))
						result.push({x:W, y:S});
					}
				}
			
				// returns every available North East, South East,
				// South West or North West cell including the times that
				// you would be squeezing through a "crack"
				function DiagonalNeighboursFree(myN, myS, myE, myW, N, S, E, W, result)
				{
					myN = N > -1;
					myS = S < worldHeight;
					myE = E < worldWidth;
					myW = W > -1;
					if(myE)
					{
						if(myN && canWalkHere(E, N))
						result.push({x:E, y:N});
						if(myS && canWalkHere(E, S))
						result.push({x:E, y:S});
					}
					if(myW)
					{
						if(myN && canWalkHere(W, N))
						result.push({x:W, y:N});
						if(myS && canWalkHere(W, S))
						result.push({x:W, y:S});
					}
				}
			
				// returns boolean value (world cell is available and open)
				function canWalkHere(x, y)
				{
					return ((world[x] != null) &&
						(world[x][y] != null) &&
						(world[x][y] <= maxWalkableTileNum));
				};
			
				// Node function, returns a new object with Node properties
				// Used in the calculatePath function to store route costs, etc.
				function Node(Parent, Point)
				{
					var newNode = {
						// pointer to another Node object
						Parent:Parent,
						// array index of this Node in the world linear array
						value:Point.x + (Point.y * worldWidth),
						// the location coordinates of this Node
						x:Point.x,
						y:Point.y,
						// the heuristic estimated cost
						// of an entire path using this node
						f:0,
						// the distanceFunction cost to get
						// from the starting point to this node
						g:0
					};
			
					return newNode;
				}
			
				// Path function, executes AStar algorithm operations
				function calculatePath()
				{
					// create Nodes from the Start and End x,y coordinates
					var	mypathStart = Node(null, {x:pathStart[0], y:pathStart[1]});
					var mypathEnd = Node(null, {x:pathEnd[0], y:pathEnd[1]});
					// create an array that will contain all world cells
					var AStar = new Array(worldSize);
					// list of currently open Nodes
					var Open = [mypathStart];
					// list of closed Nodes
					var Closed = [];
					// list of the final output array
					var result = [];
					// reference to a Node (that is nearby)
					var myNeighbours;
					// reference to a Node (that we are considering now)
					var myNode;
					// reference to a Node (that starts a path in question)
					var myPath;
					// temp integer variables used in the calculations
					var length, max, min, i, j;
					// iterate through the open list until none are left
					while(length = Open.length)
					{
						max = worldSize;
						min = -1;
						for(i = 0; i < length; i++)
						{
							if(Open[i].f < max)
							{
								max = Open[i].f;
								min = i;
							}
						}
						// grab the next node and remove it from Open array
						myNode = Open.splice(min, 1)[0];
						// is it the destination node?
						if(myNode.value === mypathEnd.value)
						{
							myPath = Closed[Closed.push(myNode) - 1];
							do
							{
								result.push([myPath.x, myPath.y]);
							}
							while (myPath = myPath.Parent);
							// clear the working arrays
							AStar = Closed = Open = [];
							// we want to return start to finish
							result.reverse();
						}
						else // not the destination
						{
							// find which nearby nodes are walkable
							myNeighbours = Neighbours(myNode.x, myNode.y);
							// test each one that hasn't been tried already
							for(i = 0, j = myNeighbours.length; i < j; i++)
							{
								myPath = Node(myNode, myNeighbours[i]);
								if (!AStar[myPath.value])
								{
									// estimated cost of this particular route so far
									myPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);
									// estimated cost of entire guessed route to the destination
									myPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);
									// remember this new path for testing above
									Open.push(myPath);
									// mark this node in the world graph as visited
									AStar[myPath.value] = true;
								}
							}
							// remember this route as having no more untested options
							Closed.push(myNode);
						}
					} // keep iterating until the Open list is empty
					return result;
				}
			
				// actually calculate the a-star path!
				// this returns an array of coordinates
				// that is empty if no path is possible
				return calculatePath();
			
			} // end of findPath() function

			var gameWorld = new GameWorld();
			gameWorld.init();

		})();
	</script>
</html>
